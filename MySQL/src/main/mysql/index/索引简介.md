###mysql索引与数据结构

1.创建索引的原因与应用场景
提高在海量数据查询过程的查询效率,减少查询时间
为什么添加索引可以减少查询时间,提高查询效率:
**MySQL最基本的存储结构是页,每个页可以组成一个双向链表而每个页中的数据记录又可以组成一个单向列表**
- 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
- 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。
所以说，如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：
定位到记录所在的页：需要遍历双向链表，找到所在的页
从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了
很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。

而使用索引相当于通过 “目录” 就可以很快地定位到对应的页上了（二分查找，时间复杂度近似为O(logn)）

2.索引的数据结构
既然索引是为了提高查询效率,而和搜索查询相关的数据结构有:
- 二叉查找树进行二分查找,以及变种:平衡二叉树,红黑树
- B-Tree
- B+-Tree
- Hash结构
其中:在Mysql中索引的数据结构是B+Tree,原因如下:
- B+树的磁盘读写代价更低:B+树内部(非叶子节点)并没有指向关键信息的指针,只存放索引信息,不存放数据;因此内部节点相对B树更小
如果将所有内部节点的索引信息存入同一盘块中,这个盘块能容纳更多的关键字,
一次性读入内存要查找的关键字也就越多,相对来说IO读写次数也就越少
- B+树的查询效率更加稳定:由于内部节点并不是最终指向文件内容的节点,而只是指向叶子节点的索引,所以任何查找都必须走一条从根节点
到叶子节点的路,所有关键字查询的长度相同,也就是说每个数据的查询效率基本一致(O(logn))
- B+树更有利于对数据库的扫描 ,B+树只需要对全部叶子节点的遍历即可完成对所有关键字的扫描,所以对数据库中频繁使用的范围查询
更有效

3.为什么不使用Hash结构作为数据库索引的数据结构?
原因如下:
Hash算法存在Hash碰撞,即不同的Key通过Hash算法得到的Hash值可能是一样的,即多个Key指向同一个Bucket,而
Bucket中又是以链表的方式进行存储Key指向的数据
所以:
- Hash索引比较的是进行Hash运算后的值也无法保证值的大小与Hash运算之前完全一样 ,
所以仅仅能满足"="与"in",不能进行范围查询
- 无法用来进行数据的排序操作 
- 不能进行部分索引进行查询,因为对于组合索引,Hash运算在是对组合索引合并之后进行的,
而不是单独计算Hash值的,索引无法使用组合索引进行数据的查询 
- 不能避免进行表扫描,因为Hash索引最终查询的还是Bucket中的entry,无法直接通过Hash值查询到数据
- 遇到大量Hash值相等的情况性能不一定比B+Tree高

4.其他索引结构:BitMap(位图索引)
关键字在一定范围内,适合使用位图索引,一般在Oracle数据库中使用
缺点:锁的密度很大

总结:
1，最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE,命中这些关键字之前的索引）就停止匹配。

2，尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。

3，索引列不能参与计算，尽量保持列“干净”。比如，FROM_UNIXTIME(create_time) = '2016-06-06' 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create_time = UNIX_TIMESTAMP('2016-06-06')。

4，尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。

5，单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引。

