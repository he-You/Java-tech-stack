序列化的意义与应用场景

- 序列化：将对象写入到IO流中
- 反序列化：从IO流中恢复对象
- 意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。
- 使用场景：所有可在网络上传输的对象都必须是可序列化的，比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；
所有需要保存到磁盘的java对象都必须是可序列化的。
通常建议：程序创建的每个JavaBean类都实现Serializeable接口。

序列化的实现方式:

如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现Serializable接口或者Externalizable接口之一。

1.普通序列化

Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。

序列化步骤：

步骤一：创建一个ObjectOutputStream输出流；

步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。

反序列化步骤：

步骤一：创建一个ObjectInputStream输入流；

步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象

注:反序列化不会调用构造方法,返序列化的对象是JVM自己生成的对象.

Java序列化算法

所有保存到磁盘的对象都有一个序列化编码号

当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。

如果此对象已经序列化过，则直接输出编号即可。

- 所有需要网络传输的对象都需要实现序列化接口，通过建议所有的javaBean都实现Serializable接口。
- 对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。
- 如果想让某个变量不被序列化，使用transient修饰。
- 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。
- 反序列化时必须有序列化对象的class文件。
- 当通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。
- 单例类序列化，需要重写readResolve()方法；否则会破坏单例原则。
- 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。
- 建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。




